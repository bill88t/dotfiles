#!/usr/bin/env python3
import os
import shutil
import argparse
from pathlib import Path
import re
import subprocess
import socket

HOME = Path.home()
SCRIPT_DIR = Path(__file__).resolve().parent
BASHRC_SOURCE = SCRIPT_DIR / "bashrc"
BASHRC_TARGET = HOME / ".bashrc"
ALACRITTY_SOURCE = SCRIPT_DIR / "alacritty.toml"
ALACRITTY_TARGET = HOME / ".alacritty.toml"
GPG_CONF_SRC = SCRIPT_DIR / "gpg-agent.conf"
GPG_CONF_DST = HOME / ".gnupg" / "gpg-agent.conf"
NIRI_SRC = SCRIPT_DIR / "niri"
NIRI_DST = HOME / ".config" / "niri"
MAKEPKG_SRC = SCRIPT_DIR / ("makepkg.conf." + os.uname()[-1])
MAKEPKG_DST = HOME / ".config" / "pacman" / "makepkg.conf"
MATLAB_DSK_SRC = SCRIPT_DIR / "matlab.desktop"
MATLAB_DSK_DST = HOME / ".local" / "share" / "applications" / "matlab.desktop"
KEYD_SRC = SCRIPT_DIR / "keyd"
KEYD_DST = Path("/etc/keyd")
CLAM_SRC = SCRIPT_DIR / "clamav"
CLAM_DST = Path("/etc/clamav")

BASE_PKGS = [
    "git",
    "git-lfs",
    "bind",
    "traceroute",
    "btop",
    "git-lfs",
    "tldr",
    "speedtest-cli",
    "screen",
    "p7zip",
    "nmap",
    "unrar",
    "unzip",
    "uncrustify",
    "pre-commit",
    "inetutils",
    "ethtool",
    "timeshift",
    "python-virtualenv",
    "python-black",
    "python-pip",
    "iw",
    "dnsmasq",
    "iperf3",
    "yt-dlp",
    "usbutils",
    "firewalld",
    "fakeroot",
    "gcc",
    "patch",
    "stress",
    "cmake",
    "which",
    "ninja",
    "zip",
    "wget",
    "curl",
    "fastfetch",
    "ccache",
    "xorg-xhost",
    "bat",
    "socat",
    "iotop",
    "tinyxxd",
]

DOCKER_PKGS = [
    "docker",
    "docker-buildx",
    "docker-compose",
    "docker-compose",
    "pigz",
    "criu",
]

NIRI_PKGS = [
    "niri",
    "cliphist",
    "swww",
    "mako",
    "swaylock",
    "archlinux-xdg-menu",
    "fuzzel",
    "alacritty",
    "nemo",
    "nemo-terminal",
    "nemo-fileroller",
    "nemo-image-converter",
    "nemo-preview",
    "mate-calc",
    "catfish",
    "waybar",
    "thunar-volman",
    "thunar-archive-plugin",
    "thunar",
    "noto-fonts-emoji",
    "inter-font",
    "xwayland-satellite",
    "xdg-desktop-portal-gnome",
    "xdg-desktop-portal-gtk",
    "polkit-kde-agent",
    "adw-gtk-theme",
    "papirus-icon-theme",
    "brightnessctl",
]

args = None


def command_exists(cmd: str) -> bool:
    return shutil.which(cmd) is not None


def install_packages(package_list: list, yay: bool = False) -> bool:
    if args.nopacman:
        return True

    try:
        print("Updating package database...")
        subprocess.run(["sudo", "pacman", "-Sy"], check=True)

        if package_list:
            print(f"Installing packages: {', '.join(package_list)}")
            cmd = ["sudo", "pacman" if not yay else "yay", "-S", "--needed", "--noconfirm"] + package_list
            subprocess.run(cmd, check=True)
        return True

    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
        return False


def confirm_overwrite(path, force) -> bool:
    if path.exists() or path.is_symlink():
        if force:
            print(f"Overwriting {path}")
            path.unlink(missing_ok=True)
        else:
            resp = input(f"{path} exists. Overwrite? [y/N] ").strip().lower()
            if resp != "y":
                print(f"Skipping {path}")
                return False
            path.unlink(missing_ok=True)
    return True


def symlink_file(src, dst, force=False) -> None:
    dst = Path(dst).expanduser()
    if not confirm_overwrite(dst, force):
        return
    dst.parent.mkdir(parents=True, exist_ok=True)
    dst.symlink_to(src)
    print(f"Linked {dst} â†’ {src}")


def install_alacritty(force=False):
    symlink_file(ALACRITTY_SOURCE, ALACRITTY_TARGET, force=force)


def install_bashrc(force=False) -> None:
    with BASHRC_SOURCE.open() as f:
        text = f.read()

    lines, entries = parse_sourcings(text)
    print("Available bashrc alias sets:\n")
    print_selection(entries)

    raw = input(
        "\nSelect which to enable (e.g. '1 3-6 8'). Leave empty to keep defaults: "
    ).strip()
    if raw:
        selected = parse_ranges(raw)
        for i, e in enumerate(entries):
            lines[e["line_num"]] = (
                f". ~/git/dotfiles/{e['name']}"
                if i in selected
                else f"#. ~/git/dotfiles/{e['name']}"
            )

    if not confirm_overwrite(BASHRC_TARGET, force):
        return

    BASHRC_TARGET.write_text("\n".join(lines) + "\n")
    print(f"Installed to {BASHRC_TARGET}")


def parse_sourcings(text: str) -> tuple:
    lines = text.splitlines()
    pattern = re.compile(r"^(\#?)\s*\. ~/git/dotfiles/([a-zA-Z0-9_]+)")
    entries = []
    for i, line in enumerate(lines):
        m = pattern.match(line)
        if m:
            commented, name = m.groups()
            entries.append(
                {
                    "line_num": i,
                    "enabled": not commented,
                    "name": name,
                }
            )
    return lines, entries


def print_selection(entries: list) -> None:
    for i, e in enumerate(entries):
        status = "[enabled]" if e["enabled"] else "[ ]"
        print(f"{i:3}. {e['name']:<25} {status}")


def parse_ranges(input_str) -> set:
    selected = set()
    for part in input_str.strip().split():
        if "-" in part:
            start, end = map(int, part.split("-"))
            selected.update(range(start, end + 1))
        else:
            selected.add(int(part))
    return selected


def list_groups():
    print("Available install targets:")
    for k in INSTALLERS:
        print(f" - {k}")


def install_gitconf(force=False):
    subprocess.run(
        'bash -c "source ~/git/dotfiles/secrets.bash && git-secrets-install"',
        shell=True,
    )


def install_gpgconf(force=False):
    gnupg_home = GPG_CONF_DST.parent
    gnupg_home.mkdir(mode=0o700, exist_ok=True)

    symlink_file(GPG_CONF_SRC, GPG_CONF_DST, force=force)

    try:
        subprocess.run(
            ["gpgconf", "--reload", "gpg-agent"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        print("Reloaded gpg-agent successfully.")
    except subprocess.CalledProcessError as e:
        print(f"Failed to reload gpg-agent: {e.stderr.decode().strip()}")


def interactive_mode(force=False):
    list_groups()
    selection = input(
        "\nWhich to install? (comma-separated or blank for all): "
    ).strip()
    if not selection:
        selected = list(INSTALLERS.keys())
    else:
        selected = [s.strip() for s in selection.split(",") if s.strip() in INSTALLERS]

    for group in selected:
        INSTALLERS[group](force=force)


def main():
    global args

    parser = argparse.ArgumentParser(description="Dotfiles installer")
    parser.add_argument("group", nargs="?", help="Group to install")
    parser.add_argument(
        "-r", "--replace", action="store_true", help="Overwrite existing files"
    )
    parser.add_argument(
        "-q", "--nopacman", action="store_true", help="Skip pacman-installing packages"
    )
    args = parser.parse_args()

    if args.group:
        if args.group not in INSTALLERS:
            print(f"Unknown group: {args.group}")
            list_groups()
            return
        INSTALLERS[args.group](force=args.replace)
    else:
        interactive_mode(force=args.replace)


# --- KDL merge helpers (brace-aware, immediate-child merge) ---
def _find_matching_brace(s: str, start: int) -> int:
    """Given index of '{' in s, return index of matching '}' (inclusive)."""
    depth = 1
    i = start + 1
    in_str = False
    esc = False
    while i < len(s):
        c = s[i]
        if in_str:
            if esc:
                esc = False
            elif c == "\\":
                esc = True
            elif c == '"':
                in_str = False
            i += 1
            continue
        # not in string
        if c == '"':
            in_str = True
            i += 1
            continue
        # skip // comments
        if c == "/" and i + 1 < len(s) and s[i + 1] == "/":
            # skip to end of line
            j = s.find("\n", i + 2)
            if j == -1:
                return len(s) - 1
            i = j + 1
            continue
        if c == "{":
            depth += 1
        elif c == "}":
            depth -= 1
            if depth == 0:
                return i
        i += 1
    raise ValueError("Unbalanced braces")


def _iter_top_blocks(s: str):
    """Yield (key, start_line_start, block_start_brace, end_brace_idx, header, inner_start, inner_end)."""
    i = 0
    while True:
        brace = s.find("{", i)
        if brace == -1:
            return
        # find start of header line
        line_start = s.rfind("\n", 0, brace)
        if line_start == -1:
            line_start = 0
        else:
            line_start += 1
        header = s[line_start:brace].strip()
        # skip if header looks empty or commented
        if not header or header.startswith("//"):
            i = brace + 1
            continue
        # Only treat as top-level if brace is at nesting level 0
        depth = 0
        j = i
        in_str = False
        esc = False
        while j < brace:
            c = s[j]
            if in_str:
                if esc:
                    esc = False
                elif c == "\\":
                    esc = True
                elif c == '"':
                    in_str = False
                j += 1
                continue
            if c == '"':
                in_str = True
                j += 1
                continue
            if c == "/" and j + 1 < len(s) and s[j + 1] == "/":
                nl = s.find("\n", j + 2)
                if nl == -1:
                    break
                j = nl + 1
                continue
            if c == "{":
                depth += 1
            elif c == "}":
                depth -= 1
            j += 1
        if depth != 0:
            i = brace + 1
            continue
        end_brace = _find_matching_brace(s, brace)
        inner_start = brace + 1
        inner_end = end_brace
        key = " ".join(header.split())  # normalize whitespace in key
        yield (key, line_start, brace, end_brace, header, inner_start, inner_end)
        i = end_brace + 1


def _split_immediate_children(block_inner: str):
    """Return (ordered_lines, ordered_blocks)
    - ordered_lines: list of (name, full_line)
    - ordered_blocks: list of (key, full_text)
    Only immediate depth-0 children within a block.
    """
    lines = []
    blocks = []
    i = 0
    depth = 0
    in_str = False
    esc = False
    line_start = 0
    while i < len(block_inner):
        c = block_inner[i]
        if in_str:
            if esc:
                esc = False
            elif c == "\\":
                esc = True
            elif c == '"':
                in_str = False
            i += 1
            continue
        if c == '"':
            in_str = True
            i += 1
            continue
        # line comments
        if c == "/" and i + 1 < len(block_inner) and block_inner[i + 1] == "/":
            nl = block_inner.find("\n", i + 2)
            if nl == -1:
                nl = len(block_inner)
            if depth == 0:
                # treat the comment as part of the current line; skip it
                pass
            i = nl + 1
            continue
        if c == "{":
            if depth == 0:
                header_line_start = block_inner.rfind("\n", 0, i)
                if header_line_start == -1:
                    header_line_start = 0
                else:
                    header_line_start += 1
                header = block_inner[header_line_start:i].strip()
                endb = _find_matching_brace(block_inner, i)
                full = block_inner[header_line_start : endb + 1]
                key = " ".join(header.split())
                blocks.append((key, full))
                i = endb + 1
                line_start = i
                continue
            depth += 1
            i += 1
            continue
        if c == "}":
            if depth > 0:
                depth -= 1
            i += 1
            continue
        if c == "\n":
            if depth == 0:
                line = block_inner[line_start:i].rstrip()
                if line.strip():
                    raw = line.strip()
                    cm = raw.find("//")
                    raw_key = raw[:cm].strip() if cm != -1 else raw
                    name = raw_key.split()[0] if raw_key else raw[:2]
                    lines.append((name, line))
                line_start = i + 1
            i += 1
            continue
        i += 1
    if line_start < len(block_inner):
        tail = block_inner[line_start:].rstrip()
        if tail.strip():
            raw = tail.strip()
            cm = raw.find("//")
            raw_key = raw[:cm].strip() if cm != -1 else raw
            name = raw_key.split()[0] if raw_key else raw[:2]
            lines.append((name, tail))
    return lines, blocks


def _merge_block_inner(base_inner: str, override_inner: str, indent: str) -> str:
    base_lines, base_blocks = _split_immediate_children(base_inner)
    o_lines, o_blocks = _split_immediate_children(override_inner)

    base_line_idx = {k: i for i, (k, _) in enumerate(base_lines)}
    base_block_idx = {k: i for i, (k, _) in enumerate(base_blocks)}

    merged_lines = list(base_lines)
    merged_blocks = list(base_blocks)

    for k, line in o_lines:
        if k in base_line_idx:
            merged_lines[base_line_idx[k]] = (k, line)
        else:
            merged_lines.append((k, line))

    for k, block in o_blocks:
        if k in base_block_idx:
            merged_blocks[base_block_idx[k]] = (k, block)
        else:
            merged_blocks.append((k, block))

    out = []
    for _, line in merged_lines:
        stripped = line.lstrip()
        out.append(indent + stripped)
    if merged_lines and merged_blocks:
        out.append("")
    for _, block in merged_blocks:
        import textwrap

        blk = textwrap.dedent(block.strip("\n"))
        blk = "\n".join(indent + ln for ln in blk.splitlines()) + "\n"
        out.append(blk)
    if out and out[-1] != "":
        out.append("")
    return "\n".join(out)


def merge_kdl_documents(base: str, override: str) -> str:
    base_blocks = list(_iter_top_blocks(base))
    base_index = {
        key: (start, end, brace, header, inner_start, inner_end)
        for key, start, brace, end, header, inner_start, inner_end in base_blocks
    }

    replacements = []
    appended = []

    for (
        key,
        o_start,
        o_brace,
        o_end,
        o_header,
        o_inner_start,
        o_inner_end,
    ) in _iter_top_blocks(override):
        o_inner = override[o_inner_start:o_inner_end]
        if key in base_index:
            b_start, b_end, b_brace, b_header, b_inner_start, b_inner_end = base_index[
                key
            ]
            b_inner = base[b_inner_start:b_inner_end]
            # detect child indent from base
            child_indent = " " * 4
            m = re.search(r"\n([ \t]+)\S", base[b_brace:b_end])
            if m:
                child_indent = m.group(1)
            merged_inner = _merge_block_inner(b_inner, o_inner, child_indent)
            new_block = base[b_start : b_brace + 1] + "\n" + merged_inner + "}\n"
            replacements.append((b_start, b_end + 1, new_block))
        else:
            block_text = override[o_start : o_end + 1]
            appended.append(block_text)

    if replacements:
        replacements.sort(key=lambda x: x[0])
        out = []
        cursor = 0
        for start, end, new_text in replacements:
            out.append(base[cursor:start])
            out.append(new_text)
            cursor = end
        out.append(base[cursor:])
        merged = "".join(out)
    else:
        merged = base

    # Extract top-level non-block lines from override and append them
    override_top_lines = []
    for line in override.split("\n"):
        stripped = line.strip()
        if (
            stripped
            and not stripped.startswith("//")
            and "{" not in stripped
            and "}" not in stripped
        ):
            # Check if this line is before any blocks
            # (simple heuristic: if line appears before first '{', it's top-level)
            if override.find(line) < override.find("{"):
                override_top_lines.append(line)

    if override_top_lines:
        merged = merged.rstrip() + "\n" + "\n".join(override_top_lines) + "\n"

    if appended:
        merged = (
            merged.rstrip()
            + "\n\n"
            + "\n\n".join(b.strip("\n") for b in appended)
            + "\n"
        )

    return merged


def _finalize_kdl_text(text: str) -> str:
    """Filter out comment lines and normalize newlines in final text."""
    final_lines = []
    for line in text.split("\n"):
        unspaced = line
        while unspaced.startswith(" "):
            unspaced = unspaced[1:]
        if unspaced and not unspaced.startswith("//"):
            final_lines.append(line)

    result = "\n".join(final_lines)
    # Normalize multiple newlines to single newline
    while "\n\n" in result:
        result = result.replace("\n\n", "\n")

    return result


# --- end helpers ---


def install_niri(force=False) -> None:
    hostname = socket.gethostname()
    general_cfg = NIRI_SRC / "general.kdl"
    device_cfg = NIRI_SRC / "devices" / f"{hostname}.kdl"
    target_dir = NIRI_DST
    target_file = target_dir / "config.kdl"

    # Install niri packages
    if not install_packages(NIRI_PKGS):
        return

    # Ensure target dir is a real directory (unlink symlink if present)
    if target_dir.is_symlink():
        target_dir.unlink()
    if target_dir.exists() and not target_dir.is_dir():
        if force:
            target_dir.unlink()
        else:
            print(
                f"{target_dir} exists and is not a directory. Use --replace to overwrite."
            )
            return
    target_dir.mkdir(parents=True, exist_ok=True)

    base = general_cfg.read_text()
    if device_cfg.exists():
        override = device_cfg.read_text()
        final_text = merge_kdl_documents(base, override)
        print(f"Merged `general.kdl` + `devices/{hostname}.kdl`")
    else:
        final_text = base
        print(f"Using `general.kdl` only (no `devices/{hostname}.kdl`).")

    # Finalize: filter comment lines and normalize newlines
    final_text = _finalize_kdl_text(final_text)

    # Write target file
    if target_file.exists() and not force:
        if not confirm_overwrite(target_file, force):
            return
    target_file.write_text(
        final_text if final_text.endswith("\n") else final_text + "\n"
    )

    print("Applying GTK theming.. ", end="")
    subprocess.run(
        [
            "gsettings",
            "set",
            "org.gnome.desktop.interface",
            "gtk-theme",
            "adw-gtk3-dark",
        ],
        check=True,
    )
    subprocess.run(
        [
            "gsettings",
            "set",
            "org.gnome.desktop.interface",
            "icon-theme",
            "Papirus-Dark",
        ],
        check=True,
    )
    print(f"OK\nInstalled Niri config -> `{target_file}`")


def install_makepkg(force=False) -> None:
    makepkg_home = MAKEPKG_DST.parent
    makepkg_home.mkdir(mode=0o700, exist_ok=True)

    symlink_file(MAKEPKG_SRC, MAKEPKG_DST, force=force)


def install_base(force=False) -> None:
    # Disable coredumps
    subprocess.run(
        [
            "sudo",
            "bash",
            "-c",
            'mkdir -p /etc/systemd && if ! grep -q "Storage=none" /etc/systemd/coredump.conf 2>/dev/null; then echo -e "[Coredump]\nStorage=none\nProcessSizeMax=0" > /etc/systemd/coredump.conf; fi && systemctl daemon-reexec && systemctl daemon-reload && systemctl restart systemd-coredump.socket 2>/dev/null || true && rm -rf /var/lib/systemd/coredump/* 2>/dev/null || true',
        ],
        check=True,
    )

    # Install core packages
    if not install_packages(BASE_PKGS):
        return

    # Yay if needed
    if (not command_exists("yay")) and not install_packages(["yay"]):
        print("yay not in repos, installing off of aur")

        subprocess.run(["mkdir", f"{HOME}/git"], check=False, shell=True)
        os.chdir(HOME)
        subprocess.run(["git", "clone", "https://aur.archlinux.org/yay-bin"], check=False)
        os.chdir("yay-bin")
        subprocess.run(["makepkg", "-si"], check=True)


def bredify(force=False) -> None:
    pass


def install_matlab(force=False) -> None:
    symlink_file(MATLAB_DSK_SRC, MATLAB_DSK_DST, force=force)
    print("Install matlab R2024b to `/home/bill88t/Matlab/R2024b`")


def install_newsrc(force=False) -> None:
    pass


def install_keyd(force=False) -> None:
    if not install_packages(["keyd"]):
        return

    print("Configuring keyd...")

    subprocess.run(["sudo", "systemctl", "stop", "keyd"])
    subprocess.run(["sudo", "mkdir", "-p", str(KEYD_DST)])

    print(f"Clearing {KEYD_DST}...")
    subprocess.run(f"sudo rm -v {KEYD_DST}/*", shell=True)

    print(f"Copying configs from {KEYD_SRC}...")
    subprocess.run(f"sudo cp -v {KEYD_SRC}/* {KEYD_DST}/", shell=True)

    print("Enabling and starting keyd service...")
    subprocess.run(["sudo", "systemctl", "enable", "--now", "keyd"])


def install_clamav(force=False) -> None:
    if not install_packages(["clamav"]):
        return

    print("Running initial database definition downloads..")
    subprocess.run(["sudo", "freshclam"])

    print("Enabling database definition downloads..")
    subprocess.run(["sudo", "systemctl", "enable", "--now", "clamav-freshclam-once.timer"])

    print("Setting up daemon..")
    subprocess.run(["sudo", "cp", "-v", f"{CLAM_SRC}/clamd.conf", f"{CLAM_DST}/clamd.conf"])
    subprocess.run(["sudo", "cp", "-v", f"{CLAM_SRC}/virus-event.bash", f"{CLAM_DST}/virus-event.bash"])
    subprocess.run(["sudo", "cp", "-v", f"{CLAM_SRC}/sudoers", "/etc/sudoers.d/clamav"])

    print("Enabling daemon..")
    subprocess.run(["sudo", "systemctl", "enable", "--now", "clamav-daemon"])

    print("Setting up real-time monitoring..")
    subprocess.run(["sudo", "cp", "-v", f"{CLAM_SRC}/clamav-clamonacc.service", "/etc/systemd/system/clamav-clamonacc.service"])

    print("Enabling real-time monitoring..")
    subprocess.run(["sudo", "systemctl", "daemon-reload"])
    subprocess.run(["sudo", "systemctl", "enable", "--now", "clamav-clamonacc"])

    print("All good.")


def disable_tumblerd(force=False) -> None:
    print("Stopping and masking tumblerd")
    subprocess.run(["systemctl", "user", "stop", "tumblerd"])
    subprocess.run(["systemctl", "user", "mask", "tumblerd"])


INSTALLERS = {
    "base": install_base,
    "bredify": bredify,
    "bashrc": install_bashrc,
    "alacritty": install_alacritty,
    "gitconf": install_gitconf,
    "gpgconf": install_gpgconf,
    "niri": install_niri,
    "makepkg": install_makepkg,
    "matlab": install_matlab,
    "newsrc": install_newsrc,
    "keyd": install_keyd,
    "tumblerd": disable_tumblerd,
}


if __name__ == "__main__":
    main()
